\documentclass{article}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[lastexercise, noanswer]{exercise} 
% for exercise 
%% Change this for title information 
\newcommand\ExTitle{Tail Recursive Functions}

\newcommand\fullExTitle{Exercises\\ \ExTitle }
\newcommand\footerExTitle{\ExTitle \ -\  Exercises }

\pagestyle{fancy}
\fancyhead{} % clear all header fields
\renewcommand{\headrulewidth}{0pt} % no line in header area
\fancyfoot{} % clear all footer fields
\fancyfoot[LE,RO]{\thepage}           % page number in "outer" position of footer line
\fancyfoot[RE,LO]{\footerExTitle} % other info in "inner" position of footer line

% \usepackage[mathrm,colour,cntbysection]{czt}

\begin{document}
\begin{Huge}
	\begin{center}
	\fullExTitle
	\end{center}
\end{Huge}
\begin{Exercise}
In the previous exercise set, you wrote the code for:
\begin{lstlisting}[language=Haskell]
	fibonacci :: Int -> Int
\end{lstlisting}
that calculates the Fibonacci number as per the following definition (note for non-negative integers)\\
$
F_{0} = 0, F_{1} = 1 \\
F_{n} = F_{n-1} + F_{n-2}
$
Now, write this fibonacci using tail recursion.

\begin{lstlisting}[language=Haskell]
	fibT :: Int -> Int
\end{lstlisting}
\end{Exercise}
\begin{Answer}
\begin{lstlisting}[language=Haskell]
fibT :: Int -> Int
fibT n = helper n 1 0  where
	  helper 1 prev prevBut1 =  prev 
	  helper n prev prevBut1 = helper (n-1) (prev+prevBut1) prev
\end{lstlisting}
\end{Answer}
\begin{Exercise}
Noting our definition of add from the previous lecture (this is actually tail recursive)
\begin{lstlisting}[language=Haskell]
myAdd :: Int -> Int -> Int
myAdd x 0 = x
myAdd 0 y = y
myAdd x y = myAdd (x-1) (y+1)
\end{lstlisting}
write a function 
\begin{lstlisting}[language=Haskell]
myMult :: Int -> Int -> Int
\end{lstlisting}
which takes two positive integers and returns the product of the two numbers. This calcluation can only use $+$ and $-$.
Ensure that the solution is tail recursive
\end{Exercise}
\begin{Answer}
non-tail recursive:
\begin{lstlisting}[language=Haskell]
recMult :: Int -> Int-> Int
recMult x 1 = x
recMult 1 y = y
recMult x y = x + recMult x (y-1)
\end{lstlisting}
and using tail recursion: 
\begin{lstlisting}[language=Haskell]
tailMult :: Int->Int-> Int
tailMult x y  = helperMult x y 0
where helperMult x y acc     
             | y ==0 = acc 
             | otherwise = helperMult x (y-1) (acc+x)
\end{lstlisting}
\end{Answer}
\begin{Exercise}
	
Given the  recursive function 
\begin{lstlisting}[language=Haskell]
reverse_ :: [a] -> [a]
reverse_ []  = []
reverse_ (x:xs) = reverse_ xs ++ [x]	
\end{lstlisting}
that returns the reverse of a list, but this time, using tail recursion.
\end{Exercise}
\begin{Answer}
\begin{lstlisting}[language=Haskell]
reverseAccum :: [a] -> [a]
reverseAccum  list = revHelper [] list
     where revHelper  accum []        = accum
           revHelper  accum (x:xs)    = revHelper (x:accum) xs
\end{lstlisting}
\end{Answer}

 %%Uncomment this for the Answers
% \newpage
% \begin{Huge}
% \begin{center}
% Solutions
% \end{center}
% \end{Huge}
% \shipoutAnswer
\end{document}